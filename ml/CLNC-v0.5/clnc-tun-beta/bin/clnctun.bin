#!/system/bin/sh

#全局变量(默认参数)
#可以通过配置文件设置
DNS=223.5.5.5
TunDev=tunx
allowWifi=1
udpflag=httpUDP

#免udp(0=关闭,1=开启,2=放行)
mudp=1

#=================================
DIR="${0%/*}"
cd $DIR/../
. ./config.ini
if [ -e config/${file}.ini ]; then
  . config/${file}.ini
else
  echo "请检查配置文件是否正确!" && exit 1
fi
export PATH=$DIR:$PATH

stopServer() {
  iptables -t nat -D OUTPUT -j CNO
  iptables -t nat -D PREROUTING -j CNP
  iptables -t mangle -D PREROUTING -j CMP
  iptables -t mangle -D OUTPUT -j CMO
  iptables -t nat -F CNO
  iptables -t nat -X CNO
  iptables -t nat -F CNP
  iptables -t nat -X CNP
  iptables -t mangle -F CMP
  iptables -t mangle -X CMP
  iptables -t mangle -F CMO
  iptables -t mangle -X CMO
  iptables -F FORWARD
  busybox killall tun2socks clnc 2>&-
  ip route del local default dev lo table 1234
  ip rule del fwmark 0x1234 lookup 1234
  ip tuntap del mode tun $TunDev
  ip rule del from all fwmark 0x1234 lookup 1234
  if [ "$denyIpv6" == '1' ]; then
    ip6tables -t mangle -P OUTPUT DROP
    ip6tables -t mangle -P FORWARD DROP
  else
    ip6tables -t mangle -P OUTPUT ACCEPT
    ip6tables -t mangle -P FORWARD ACCEPT
  fi
}

tunDevStart(){
  [ ! -e "/dev/net/tun" ] && mkdir -p /dev/net && ln -s /dev/tun /dev/net/tun && echo 1 > /proc/sys/net/ipv4/ip_forward
  ip tuntap add mode tun $TunDev >/dev/null 2>&1
  ip addr add 10.0.0.1/24 dev $TunDev >/dev/null 2>&1
  ip link set $TunDev up >/dev/null 2>&1
  nohup tun2socks --tundev $TunDev --netif-ipaddr 10.0.0.2 --netif-netmask 255.255.255.0 --socks-server-addr 127.0.0.1:1260 --enable-udprelay --loglevel 1 >/dev/null 2>&1 &
}

#通过包名得到uid
getPackageUid() {
  packageName=${1%%_*}  #过滤包名后面的端口
  if echo $packageName | grep -q '[A-Za-z]'; then
    packageInfo=`grep -oE "^$packageName ([0-9])+" /data/system/packages.list`
    [ $? != 0 ] && return 1
    echo "$1" | grep -qE '_([0-9])+' && \
      echo "${packageInfo#* }_${1#*_}" || \
      echo "${packageInfo#* }"
  else
    echo "$1"
  fi
}

startIptables() {
  # 防跳
  iptables -t nat -N CNO
  iptables -t nat -A CNO -d $ip -p tcp --dport ${addr#*:} -m owner --uid-owner 0 -j ACCEPT
  [ "$allowWifi" = "1" ] && iptables -t nat -A CNO -o wlan+ -j ACCEPT
  iptables -t nat -A CNO -o tun+ -j ACCEPT
  iptables -t nat -A CNO -o lo -j ACCEPT
  # 防止WiFi共享获取不到ip
  iptables -t nat -A CNO -d 192.168/16 -j ACCEPT
  [ "$allowTcpPorts" != "" ] && iptables -t nat -A CNO -p tcp -m multiport --dports $allowTcpPorts -j ACCEPT
  [ "$allowUdpPorts" != "" -a "$mudp" = "0" ] && iptables -t nat -A CNO -p udp -m multiport --dports $allowUdpPorts -j ACCEPT
  # 本地TCP放行
  for app in $allowAppsTCP; do
    uid=`getPackageUid $app` || continue
    iptables -t nat -A CNO -p tcp -m owner --uid ${uid%_*} `echo $uid|grep -q '_' && echo "-m multiport --dport ${uid#*_}"` -j ACCEPT
  done
  if [ "$mudp" = "0" ]; then
    # 本地UDP放行
    for app in $allowAppsUDP; do
      uid=`getPackageUid $app` || continue
      iptables -t nat -A CNO -p udp -m owner --uid ${uid%_*} `echo $uid|grep -q '_' && echo "-m multiport --dport ${uid#*_}"` -j ACCEPT
    done
  fi
  # 本地全局放行
  for app in $allowApps; do
    uid=`getPackageUid $app` || continue
    iptables -t nat -A CNO -m owner --uid $uid -j ACCEPT
  done
  iptables -t nat -A CNO -p tcp -j REDIRECT --to-ports 1230
  iptables -t nat -A CNO -p udp --dport 53 -j REDIRECT --to-ports 1240
  [ "$mudp" = '0' ] && iptables -t nat -A CNO ! -p tcp -j REDIRECT --to-ports 1250
  [ "$mudp" = '1' ] && iptables -t nat -A CNO ! -p udp -j REDIRECT --to-ports 1250
  iptables -t nat -I OUTPUT -j CNO

  # 共享规则
  iptables -t nat -N CNP
  [ "$allowShareTcpPorts" != "" ] && iptables -t nat -A CNP -p tcp -m multiport --dports $allowShareTcpPorts -j ACCEPT
  [ "$allowShareUdpPorts" != "" ] && iptables -t nat -A CNP -p udp -m multiport --dports $allowShareUdpPorts -j ACCEPT
  iptables -t nat -A CNP -s 192.168/16 ! -d 192.168/16 -p tcp -j REDIRECT --to-ports 1230
  iptables -t nat -A CNP -s 192.168/16 -p udp --dport 53 -j REDIRECT --to-ports 1240
  #[ "$mudp" = '1' ] || iptables -t nat -A CNP -s 192.168/16 -p udp --dport 53 -j REDIRECT --to-ports 53
  [ "$mudp" = '0' ] && iptables -t nat -A CNP ! -p tcp -j REDIRECT --to-ports 1250
  [ "$mudp" = '1' ] && iptables -t nat -A CNP ! -p udp -j REDIRECT --to-ports 1250
  iptables -t nat -I PREROUTING -j CNP

  # 免udp规则
  if [ "$mudp" == '1' ]; then
    # PREROUTING
    iptables -t mangle -N CMP
    [ "$allowShareUdpPorts" != "" ] && iptables -t mangle -A CMP -p udp -m multiport --dports $allowShareUdpPorts -j ACCEPT
    for allowIp in 127/8 192.168/16 10/8 224/3 0/8 172.16/12 100.64/10 169.254/16
    do
      iptables -t mangle -A CMP -d $allowIp -j ACCEPT
    done

    # OUTPUT
    iptables -t mangle -N CMO
    [ "$allowUdpPorts" != "" ] && iptables -t mangle -A CMO -p udp -m multiport --dports $allowUdpPorts -j ACCEPT
    # 本地UDP放行
    for app in $allowAppsUDP; do
      uid=`getPackageUid $app` || continue
      iptables -t mangle -A CMO -p udp -m owner --uid ${uid%_*} `echo $uid|grep -q '_' && echo "-m multiport --dport ${uid#*_}"` -j ACCEPT
    done
    # 本地全局放行
    for app in $allowApps; do
      uid=`getPackageUid $app` || continue
      iptables -t mangle -A CMO -m owner --uid $uid -j ACCEPT
    done
    [ "$allowWifi" = "1" ] && iptables -t mangle -A CMO -o wlan+ -j ACCEPT
    iptables -t mangle -A CMO -o tun+ -j ACCEPT
    if [ "$useTun" == '1' ]; then
    # tun2socks/TPROXY 选择
      tunDevStart
      sleep 0.1
      ip route replace default dev $TunDev table 1234
      ip rule add from all fwmark 0x1234 lookup 1234
      iptables -t mangle -A CMP ! -i tun+ -p udp ! --dport 53 -j MARK --set-mark 0x1234
      iptables -t mangle -A CMO ! -d 192.168/16 ! -o lo -p udp ! --dport 53 -j MARK --set-mark 0x1234

      iptables -A FORWARD -i $TunDev
      iptables -A FORWARD -o $TunDev
    else
      ip route add local default dev lo table 1234
      ip rule add fwmark 0x1234 lookup 1234
      iptables -t mangle -A CMP ! -i tun+ -p udp ! --dport 53 -j TPROXY --on-port 1230 --tproxy-mark 0x1234
      iptables -t mangle -A CMO ! -d 192.168/16 ! -o lo -p udp ! --dport 53 -j MARK --set-mark 0x1234
    fi
    iptables -t mangle -A OUTPUT -j CMO
    iptables -t mangle -A PREROUTING -j CMP
  fi
}

getIpWget() {
  if [[ $(echo $ip | grep -E '[a-z\|A-Z]') != "" && "$flag" == "1" ]]; then
    isip=$(busybox wget -q -T1 -O- http://119.29.29.29/d?dn=$ip | busybox cut -d';' -f1)
    checkip=$(echo "$isip" | busybox grep '\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}')
    if [ "$isip" != "" -a "$isip" = "$checkip" ]; then
      ip=$isip
      addr=$isip:${addr#*:}
      flag=0
    else
      jxjg="解析IP失败！($ip)\n"
      flag=1
    fi
  fi
}

getIpPing() {
  if [[ $(echo $ip | grep -E '[a-z\|A-Z]') != "" && "$flag" == "1" ]]; then
    isip=$(ping -c1 -w1 -W1 $ip | grep 'PING' | busybox cut -d'(' -f2 |  busybox cut -d')' -f1)
    checkip=$(echo "$isip" | busybox grep '\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}')
    if [ "$isip" != "" -a "$isip" = "$checkip" ]; then
      ip=$isip
      addr=$isip:${addr#*:}
      flag=0
    else
      jxjg="解析IP失败！($ip)\n"
      flag=1
    fi
  fi
}

getIp() {
  ip=${addr%:*}
  echo "$ip" | grep -q '\([0-9]\{1,3\}\.\)\{3\}[0-9]\{1,3\}' && return 0 || flag=1
  getIpWget
  getIpPing
  [ "$flag" = "1" ] && echo $jxjg && exit 1
}

dataControl() {
  if [ "$netstat" != "$1" -a "$kgwl" = "1" ]; then
  wifiip=$(busybox ifconfig wlan0 2>&- | busybox grep 'inet addr')
    if [ "$wifiip" = "" ]; then
      [ "$1" = "y" ] && svc data enable && sleep 0.1
      [ "$1" = "n" ] && svc data disable && sleep 0.01
      netstat="$1"
    fi
  fi
}

makeConfigWithoutEncrypt() {
echo '
tcp::Global {
    tcp_listen = 0.0.0.0:1230;
}

dns::Global {
    dns_listen = 0.0.0.0:1240;
    cacheLimit = 512;
    cachePath = /dev/null;
}' > bin/clnc.conf

echo -E '
httpMod::clns_http_request {
    del_line = host;
    del_line = x-online-host;
    set_first = "[M] http://'$host'[U] [V]\r\nHost: '$host'\r\n'$clnchead': [H]\r\n";
}
' >> bin/clnc.conf

echo 'httpMod::clns_https_request {
    del_line = host;' >> bin/clnc.conf
if [ "$method" == "GET" -o "$method" == "POST" ]; then
echo -E '    set_first = "'$method' '$path' [V]\r\nHost: '$host'\r\n'$clnchead': [H]\r\nClnsProxyType: TUNNEL_PROXY\r\n";' >> bin/clnc.conf
fi
if [ "$method" == "CONNECT" ]; then
echo -E '    set_first = "CONNECT '$path' [V]\r\nHost: '$host'\r\n'$clnchead': [H]\r\n";' >> bin/clnc.conf
fi
if [ "$method" == "WS" -o "$method" == "ws" ]; then
echo -E '    set_first = "GET /ws HTTP/1.1\r\nHost: '$host'\r\n'$clnchead': [H]\r\nConnection: Upgrade\r\nSec-WebSocket-Key: Cute Linux Network\r\nSec-WebSocket-Version: 13\r\nUpgrade: websocket\r\nOrigin: http://'$host'/\r\nClnsProxyType: TUNNEL_PROXY\r\n";'>> bin/clnc.conf
fi
echo '}

tcpProxy::https_proxy {
    destAddr = '$addr';
    tunnel_proxy = on;
    tunnelHttpMod = clns_https_request;
    httpMod = clns_http_request;
}

tcpAcl::firstConnect {
    tcpProxy = https_proxy;
    matchMode = firstMatch;
    dst_port != 0;
}

dnsAcl {
    destaddr = '$addr';
    header_host = '$DNS':53;
    lookup_mode = tcpdns;
    tunnelHttpMod = clns_https_request;
    tunnel_proxy = on;
}

httpUDP::udp {
    udp_tproxy_listen = 0.0.0.0:1230;
    udp_socks5_listen = 0.0.0.0:1260;
    header_host = '$host';
    destAddr = '$addr';
    udp_flag = '$udpflag';
    httpMod = clns_https_request;
}

socks5::recv_socks5 {
    socks5_listen = 0.0.0.0:1260;
}
' >> bin/clnc.conf

}

makeConfigWithEncrypt() {
echo '
tcp::Global {
    tcp_listen = 0.0.0.0:1230;
}

dns::Global {
    dns_listen = 0.0.0.0:1240;
    cacheLimit = 512;
    cachePath = /dev/null;
}

httpMod::clns_https_request {
    del_line = host;' > bin/clnc.conf
if [ "$method" == "GET" -o "$method" == "POST" ]; then
echo -E '    set_first = "'$method' '$path' [V]\r\nHost: '$host'\r\n'$clnchead': [H]\r\nClnsProxyType: TUNNEL_PROXY\r\n";' >> bin/clnc.conf
fi
if [ "$method" == "CONNECT" ]; then
echo -E '    set_first = "CONNECT '$path' [V]\r\nHost: '$host'\r\n'$clnchead': [H]\r\n";' >> bin/clnc.conf
fi
if [ "$method" == "WS" -o "$method" == "ws" ]; then
echo -E '    set_first = "GET /ws HTTP/1.1\r\nHost: '$host'\r\n'$clnchead': [H]\r\nConnection: Upgrade\r\nSec-WebSocket-Key: Cute Linux Network\r\nSec-WebSocket-Version: 13\r\nUpgrade: websocket\r\nOrigin: http://'$host'/\r\nClnsProxyType: TUNNEL_PROXY\r\n";'>> bin/clnc.conf
fi
echo '}

tcpProxy::https_proxy {
    destAddr = '$addr';
    tunnel_encrypt = '$clncpwd';
    tunnel_proxy = on;
    tunnelHttpMod = clns_https_request;
}

tcpAcl::firstConnect {
    tcpProxy = https_proxy;
    matchMode = firstMatch;
    dst_port != 0;
}

dnsAcl {
    destaddr = '$addr';
    header_host = '$DNS':53;
    lookup_mode = tcpdns;
    tunnel_encrypt = '$clncpwd';
    tunnelHttpMod = clns_https_request;
    tunnel_proxy = on;
}

httpUDP::udp {
    udp_tproxy_listen = 0.0.0.0:1230;
    udp_socks5_listen = 0.0.0.0:1260;
    header_host = '$host';
    destAddr = '$addr';
    encrypt = '$clncpwd';
    udp_flag = '$udpflag';
    httpMod = clns_https_request;
}

socks5::recv_socks5 {
    socks5_listen = 0.0.0.0:1260;
}
' >> bin/clnc.conf
}

makeConfig() {
 if [[ "$clncpwd" == "" ]]; then
   makeConfigWithoutEncrypt
 else
   makeConfigWithEncrypt
 fi
}

startServer() {
  # 启动程序
  chmod 777 bin/*
  clnc -c bin/clnc.conf &>/dev/null
}

clearFile() {
  rm -f config/*.bak bin/*.bak bin/*.conf
}

statusCheck() {
  ip addr | grep global | grep -E '[1-9]{1,3}[0-9]{0,2}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | \
  while read line
  do
    [ -z "$line" ] && break
    typeset -L17 netcard=${line##* }
    IP=${line%%/*}
    echo "$netcard${IP##* }"
  done
  echo
  [ -n "$IP" ] && echo
  echo -n "✺ 核心程序:  "
  busybox pidof "clnc" >/dev/null && echo -n "✔clnc  " || echo -n "✘clnc  "
  if [ "$useTun" = "1" -a "$mudp" = "1" ]; then
    busybox pidof "tun2socks" >/dev/null && echo -n "✔tun2socks  " || echo -n "✘tun2socks  "
  else
    busybox pidof "tun2socks" >/dev/null && echo -n "✔tun2socks  "
  fi

  echo -e "\n"
  echo ✺ nat表 CNO链:
  iptables -t nat -S CNO
  echo ""
  echo ✺ nat表 CNP链:
  iptables -t nat -S | grep -q 'PREROUTING -j CNP' && iptables -t nat -S CNP
  if [ "$mudp" = "1" ]; then
    echo ""
    echo ✺ mangle表 CMP链:
    iptables -t mangle -S | grep -q 'PREROUTING -j CMP' && iptables -t mangle -S CMP
    echo ""
    echo ✺ mangle表 CMO链:
    iptables -t mangle -S CMO
  fi
}

main() {
  if [ "$1" = "stop" ]; then
    stopServer 2>&-
  elif [ -z "$1" -o "$1" = "start" ]; then
    stopServer 2>&-
    getIp
    makeConfig
    startIptables 2>&-
    startServer
    dataControl n
    dataControl y
    sleep 0.2
  fi
  sleep 0.1
  statusCheck
  clearFile
}

main $1